function coef = computeCorrelationCoef(datesPeriods, salesPeriods, maxTempPeriods, slopeAvg)  % Each sales data point transformed based on the slope and the average of  % its period  filteredTemps = [];  filteredDates = [];  transformedSales = [];  for periodIndex = 1:size(datesPeriods, 1)        % Get data for current period    salesPeriod = salesPeriods(periodIndex, :);    tempPeriod = maxTempPeriods(periodIndex, :);    validIndexes = intersect(find(salesPeriod > 0), find(tempPeriod >= 10));       % Nothing to do if none of the data is valid    if length(validIndexes) == 0      continue;    end        % Filter invalid data    datesPeriod = datesPeriods(periodIndex, :)(validIndexes);    salesPeriod = salesPeriod(validIndexes);    tempPeriod = tempPeriod(validIndexes);        deltaSalesPlusMean = salesPeriod - slopeAvg .* (datesPeriod - mean(datesPeriod));    filteredDates = [filteredDates datesPeriod];    filteredTemps = [filteredTemps tempPeriod];    transformedSales = [transformedSales deltaSalesPlusMean];  end  % Analyse the last year seperately  firstDayOfYr3 = 732;  % The 3rd year data excluding outliers  indexesYr3 = find(filteredDates >= firstDayOfYr3);  yr3Outliers = findOutliers(transformedSales(indexesYr3));  indexesYr3 = setdiff(indexesYr3, yr3Outliers);                                            % Yr1 and Yr2 data excluding outliers                   indexesYr1And2 = find(filteredDates < firstDayOfYr3);  yr1And2Outliers = findOutliers(transformedSales(indexesYr1And2));  indexesYr1And2 = setdiff(indexesYr1And2, yr1And2Outliers);  % Normalise the data before putting it back together  normalise = @(data) (data - min(data)) / (max(data) - min(data));  sales12 = normalise(transformedSales(indexesYr1And2));  sales3 = normalise(transformedSales(indexesYr3));  % Compute coefficient  coef = corrcoef(filteredTemps([indexesYr1And2, indexesYr3]), [sales12 sales3])(1,2);
endfunction
